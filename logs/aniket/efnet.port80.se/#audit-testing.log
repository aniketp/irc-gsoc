[2018-04-24 15:02:14] * aniketp41 (~aniketp41@159.65.149.37) join
[2018-04-24 15:02:14] * efnet.port80.se mode +n
[2018-04-24 15:02:14] * efnet.port80.se mode +t
[2018-04-24 15:22:42] * somers_ (~somers@63-224-81-165.hlrn.qwest.net) join
[2018-04-24 22:58:37] <aniketp41> Hi Alan, am I supposed to get an email with FreeBSD for mailing list communication? The page here mentioned setting up the Project Wiki and Self page along with FreeBSD email address. https://wiki.freebsd.org/SummerOfCodeStudentChecklist
[2018-04-25 05:26:45] * somers__ (~somers@63-224-81-204.hlrn.qwest.net) join
[2018-04-25 05:28:39] * somers_ (~somers@63-224-81-165.hlrn.qwest.net) quit Ping timeout: 252 seconds
[2018-04-25 05:30:06] <aniketp41> Hi Alan, did you see the previous message before ping timeout?
[2018-04-25 19:22:29] <aniketp41> ping @somers__ 
[2018-04-25 19:24:26] <somers__> I don't know what you're "supposed" to get
[2018-04-25 19:24:29] <somers__> what are you expecting?
[2018-04-25 19:25:09] <somers__> BTW aniketp41, if you want to get my attention on IRC, you should mention my nick.  I sit in some high traffic rooms, so my client doesn't alert me unless my nick gets mentioned
[2018-04-25 20:25:21] <aniketp41> somers__ The checklist page mentioned about a username for SVN SummerOfCode repository which would also be used as the email, so I wonmdered if is it provided or would I need to create one for myself?
[2018-04-25 20:25:21] <aniketp41> Also, I have created a WikiPage "AniketPandey" and the page says to ask a FreeBSD developer to include my account in the Contributer's Group. So I was wondering if you could do that..
[2018-04-25 21:48:42] <aniketp41> ping somers__
[2018-04-25 22:02:48] <somers__> Ahh, to get your SVN account you'll have to email soc-admins@freebsd.org, as detailed at https://wiki.freebsd.org/SummerOfCodeSubversion
[2018-04-25 22:03:21] <somers__> Tell them you'll need a branch of the src tree
[2018-04-25 22:05:07] <somers__> Where is your "AniketPandey" wiki page?  I can't find it.
[2018-04-25 22:06:20] <aniketp41> Oh, guess it isn't created yet. I created my account but I can't create my page as I don't have the edit access.
[2018-04-25 22:08:40] <somers__> Ok, try again
[2018-04-25 22:32:33] <aniketp41> Thanks somers__ ! I created a basic page and would keep it updated throughout the project
[2018-04-25 22:32:33] <aniketp41> https://wiki.freebsd.org/AniketPandey
[2018-04-25 22:43:28] <aniketp41> Btw @somers__ , Would you advise on testing auditdistd(8) as well? A contributer Mateusz Piotrowski emailed me asking about it.
[2018-04-26 03:11:32] <somers__> aniketp41 I would consider auditdistd to be a stretch goal.  Testing the auditing itself is more important.
[2018-04-26 15:14:58] * somers__ (~somers@63-224-81-204.hlrn.qwest.net) quit Remote host closed the connection
[2018-04-26 16:07:57] * somers (~somers@2602:3f:e051:cc00:e23f:49ff:fe44:d7b6) join
[2018-04-26 23:07:07] * somers_ (~somers@63-224-81-240.hlrn.qwest.net) join
[2018-04-26 23:08:35] * somers (~somers@2602:3f:e051:cc00:e23f:49ff:fe44:d7b6) quit Ping timeout: 252 seconds
[2018-04-27 00:40:28] <aniketp41> Hi @somers_, Does your work at Spectra involve FreeBSD? I was just curious. As I've noticed that quite a few FreeBSD devs contribute to it as a part-time hobby, while others use it at work. 
[2018-04-27 13:08:39] * somers__ (~somers@63-224-80-23.hlrn.qwest.net) join
[2018-04-27 13:09:14] <somers__> Yeah, Spectra's products run on FreeBSD
[2018-04-27 13:10:49] * somers_ (~somers@63-224-81-240.hlrn.qwest.net) quit Ping timeout: 252 seconds
[2018-04-27 16:15:36] * somers_ (~somers@63-224-80-107.hlrn.qwest.net) join
[2018-04-27 16:17:49] * somers__ (~somers@63-224-80-23.hlrn.qwest.net) quit Ping timeout: 252 seconds
[2018-04-29 13:36:29] <aniketp41> Hi @somers_, I mailed the soc-admins about getting a subversion account and a branch in socsvn repository. Also, my semester exams ended today so I'll regularly update you on my work from now on
[2018-04-29 13:39:32] * rwatson (robert@fledge.watson.org) join
[2018-04-29 14:04:21] <somers_> cool
[2018-04-29 14:47:36] <aniketp41> Btw @somers_, how much time does it take to "buildworld" the freebsd kernel by a single job? I was trying to build my tests by compiling the "/usr/src" and its been running for the last 10 minutes..
[2018-04-29 14:48:25] <aniketp41> Although I later realized that the guide here https://www.freebsd.org/doc/handbook/makeworld.html recommended four jobs (-j4)
[2018-04-29 14:48:38] <somers_> Depends on what kind of machine you have.  "buildworld" can take anywhere from 10 minutes to 2.5 hours on typical hardware
[2018-04-29 14:49:00] <somers_> But once you've built it once, you can do "make -DNO_CLEAN buildworld" on subsequent invocations
[2018-04-29 14:51:30] <somers_> The number of jobs should be at least equal to the number of CPU cores.  If you're I/O is slow, then use up to 2x number of cores for your job number
[2018-04-29 14:51:33] <aniketp41> I created a separate VM for specifically this task and it does not have very good specs. so by what you said it might take a long time
[2018-04-29 14:51:39] <somers_> Is your source directory mounted over NFS?
[2018-04-29 14:52:46] <aniketp41> No it is simple UFS
[2018-04-29 14:53:24] <somers_> Ok, that's fine then.  Just give your VM as much CPU and RAM as you can, set the jobs number appropriately, and wait.
[2018-04-29 15:04:37] <aniketp41> Wow, it's building quite fast, my main machine had 8 cores and 16 gigs of ram which allowed me to allocate 4 cores and about 10 gigs to my VM. With 8 jobs it's doing well!
[2018-04-29 15:05:04] <somers_> cool!  What kind of storage does it have?
[2018-04-29 15:09:43] <aniketp41> I think its HDD, although the Virtualbox showed an option to have an SSD partition
[2018-04-29 15:10:07] <somers_> What's important is the physical device, not how VirtualBox displays it
[2018-04-29 15:10:20] <aniketp41> Though my main machine has 256 gigs SSD
[2018-04-29 15:10:52] <somers_> If you have SSD storage and 4 cores, then 8 build jobs is too many.  Just use 5-6
[2018-04-29 15:15:56] <aniketp41> Okay, I'll keep it in mind the next time I try building the kernel
[2018-04-29 15:53:04] <aniketp41> So it took 46 minutes approx to buildworld. Now doing buildkernel with 6 jobs now
[2018-04-30 00:36:54] <aniketp41> Hi @somers_, I was reading about non-blocking sockets for testing network APIs as you suggested in a previous mail. But I couldn't come up with any idea about how this would help me in writing the test program. For instance, to have all system calls in one place, I'll need to have both client and server running in the single program, but how would using non-blocking socket help me? AFAIK it would just prevent accept(2), recv(2) from blocking the connection. 
[2018-04-30 00:42:38] <aniketp41> I also had another idea about the approach that I might follow. Till now I've been testing the file-create/read audit_events independently, so what if I use the same approach for network system calls that don't need a client (or a server, the other way), like socket(2), bind(2), setsockopt(2), listen(2) etc. Once I've confirmed their audit, I can simply close the socket as I don't really need a connection here.
[2018-04-30 00:42:38] <aniketp41> As for syscalls like accept(2), connect(2), send(2), recv(2) etc, that need a connection, I can have a separate binary which I can execute using system(3) and them call the syscall from my kyua test-case, and finally poll into auditpipe(4) to check if that particular syscall is audited or not? This approach is a bit weird since I will need external socket-programs, but might actually work! Please provide your inputs for this.. 
[2018-04-30 03:42:12] * somers_ (~somers@63-224-80-107.hlrn.qwest.net) quit Read error: Connection reset by peer
[2018-04-30 03:43:37] * somers_ (~somers@63.224.80.107) join
[2018-04-30 03:44:09] * somers_ (~somers@63.224.80.107) quit Remote host closed the connection
[2018-04-30 03:45:41] * somers_ (~somers@63-224-80-107.hlrn.qwest.net) join
[2018-04-30 06:14:38] * somers__ (~somers@63-224-80-93.hlrn.qwest.net) join
[2018-04-30 06:16:56] * somers_ (~somers@63-224-80-107.hlrn.qwest.net) quit Ping timeout: 252 seconds
[2018-04-30 07:37:37] * somers_ (~somers@63-224-81-79.hlrn.qwest.net) join
[2018-04-30 07:39:47] * somers__ (~somers@63-224-80-93.hlrn.qwest.net) quit Ping timeout: 252 seconds
[2018-04-30 13:47:25] <aniketp41> ping @somers_
[2018-04-30 14:08:34] <somers_> I don't think you should use external helper programs
[2018-04-30 14:09:25] <somers_> All of the networking syscalls should be testable using a single thread, with nonblocking sockets
[2018-04-30 14:09:35] <somers_> Is there one in particular that you're having trouble with?
[2018-04-30 14:13:08] <aniketp41> So like if I have a server with non-blocking socket, how would I connect(2) using the client? I'm not sure how I would put the client within the same program.
[2018-04-30 14:15:18] <somers_> The "server" would set its socket to be nonblocking, and call listen.  Then the "client" would set its end to nonblocking, and call connect.  Finally, the "server" would call accept.
[2018-04-30 14:16:09] <somers_> I'm not sure if the connect call would succeed, or return EINPROGRESS.  I think it would succeed as long as the socket is listening.
[2018-04-30 15:26:14] <aniketp41> Hi @somers_, The method you suggested worked. I followed the same pattern, server->listen, client->connect, server->accept and all the basic network APIs were audited
[2018-04-30 15:26:16] <aniketp41> https://pastebin.com/Pp3wBMCV
[2018-04-30 15:26:45] <aniketp41> Please ignore the formatting as I'll improve it in the formal program!
[2018-04-30 15:28:31] <aniketp41> Audit result: https://pastebin.com/g15LQ9gM
[2018-04-30 15:31:03] <aniketp41> But on my Linux main machine it returns EINPROGRESS: Connect error: Operation now in progress
[2018-04-30 16:20:18] <aniketp41> @somers_, would polling be a solution for EINPROGRESS issue here? Although this this did not happen in my FreeBSD machine, but it did in Linux 
[2018-04-30 16:26:53] <aniketp41> Also, @somers_, @rwatson,  I was testing unlink(2) and unlinkat(2) system call which is under "ad": administrative audit_class but the audit was unsuccessful on setting "ad" as the audit flag while on setting the flag as "all", it was successful  
[2018-04-30 16:27:12] <aniketp41> Is "ad" really the audit_class for unlink(at)(2)?
[2018-04-30 16:27:49] <aniketp41> Oh sorry its fd, my mistake!
[2018-04-30 18:13:46] <aniketp41> ping @somers_
[2018-04-30 18:27:30] <somers_> Yes?
[2018-04-30 18:31:56] <somers_> @aniketp41 in your connect test, it looks like the client is trying to connect to 0.0.0.0:9000.  I'm not even sure what it means to connect to 0.0.0.0.  Your results might be more portable if it connects to 127.0.0.1
[2018-04-30 18:35:36] <somers_> But the error on Linux probably means that the connection attempt is in progress, and you should use select(2) to know when it's complete
[2018-04-30 18:57:13] <aniketp41> Yes @somers_, I think I'll have to change this "server.sin_addr.s_addr = "INADDR_ANY" to "inet_addr("127.0.0.1")"
[2018-04-30 19:03:15] <aniketp41> It might have been trying to connect to all available interfaces (i.e 0.0.0.0)
[2018-05-01 03:19:56] * gnn (~quassel@f373.x.rootbsd.net) join
[2018-05-01 03:20:03] <gnn> aniketp41: Hello.
[2018-05-01 08:28:56] <aniketp41> Hello @gnn, thanks for joining the channel!
[2018-05-01 10:37:03] * aniketp41 (~aniketp41@159.65.149.37) join
[2018-05-01 16:18:52] <aniketp41> Hi @gnn, I'm working in the organization of files in the test-suite as I arranged it as such before I started creating Kyua test-cases. 
[2018-05-01 21:38:02] <aniketp41> Hi @somers_, how did you compile the Kyua test-program that I shared with you once? 
[2018-05-01 21:38:02] <aniketp41> I'm currently having a trouble with linking the <atf-c.h> header with the main program
[2018-05-01 21:38:22] <aniketp41> Here is the link to the error produced https://pastebin.com/La8Wvexh
[2018-05-01 21:39:16] <aniketp41> I tried compiling with the example shown here https://github.com/jmmv/kyua/wiki/Quickstart-atf-c-test#atf_tests2c---test-program-with-multiple-test-cases but it doesn't seem to work
[2018-05-01 21:41:28] <somers_> @aniketp41 I put the program in tests/sys/audit and wrote this to tests/sys/audit/Makefile:
[2018-05-01 21:41:45] <somers_> ESTSDIR=       ${TESTSBASE}/sys/audit
[2018-05-01 21:41:45] <somers_> ATF_TESTS_C+=   mkdir-atf0
[2018-05-01 21:41:45] <somers_> TEST_METADATA.mkdir-atf0+= timeout="30"
[2018-05-01 21:41:45] <somers_> CFLAGS+=        -I${.CURDIR:H:H}
[2018-05-01 21:41:45] <somers_> WARNS?= 6
[2018-05-01 21:41:46] <somers_> .include <bsd.test.mk>
[2018-05-01 21:46:00] <aniketp41> Yes I followed a similar makeshift procedure of putting the tests in /usr/src/sbin/devd/tests and replaced the content of its Makefile to test mkdir-atf0.c instead of client-test.c and it worked.
[2018-05-01 21:46:00] <aniketp41> But now that I'm trying to separate the setup functions in a separate C file so that I can share it with multiple test programs but I'm unable to link it properly. Can you suggest me a way to do so?
[2018-05-01 21:46:20] <aniketp41> Possibly making some modifications to the Makefile?
[2018-05-01 21:48:49] <somers_> So you want to build a single binary from two .c files?  Then you need to specify the SRCS variable.  Take a look at sys/geom/class/eli/Makefile
[2018-05-01 21:49:03] <somers_> err, tests/sys/geom/class/eli/Makefile
[2018-05-01 21:55:24] <aniketp41> @somers_, is there supposed to be a Makefile in the test-suite? I only found a bunch of tests and a Kyuafile.. 
[2018-05-01 21:55:39] <aniketp41> at /usr/tests/sys/geom/class/eli
[2018-05-01 21:55:49] <somers_> I'm talking about the source directory
[2018-05-02 01:51:16] <aniketp41> @somers_, using the Makefile you provided was giving quite a lot of errors which I didn't get before, some of them referenced no extern declaration for non-static global variables, which made sense. But a lot of the other errors should've been a warning (shadowing global scope) unless its too strict. Here is the list: https://pastebin.com/wPAxNJat
[2018-05-02 02:37:41] <aniketp41> Hi @somers_, I made a few changes to remove all the errors, please have a look at the changes and suggest any improvements https://github.com/aniketp/AuditTestSuite/commit/b456c15c7dc2a8728b764f49d8429fbee8fb37f9
[2018-05-02 02:37:46] <somers_> Yeah, those are all errors in your code.
[2018-05-02 02:38:36] <somers_> We should switch from reviewing on Github to using Phabricator, now that you've got a full src tree setup
[2018-05-02 02:38:59] <somers_> https://wiki.freebsd.org/Phabricator
[2018-05-02 02:42:33] <aniketp41> src tree setup in socsvn repository branch? I didn't receive any notification about it..
[2018-05-02 02:43:22] <somers_> Do you have an svn account yet?  You can create the branch yourself if so
[2018-05-02 03:00:22] <aniketp41> I don't think I have an SVN account yet, was waiting for confirmation from the soc-admins. But I had created an account earlier in FreeBSD's Phabricator. i.e https://reviews.freebsd.org/
[2018-05-02 03:40:01] <aniketp41> Btw @somers_, adding SRCS+=filename.c to the above Makefile do the job?
[2018-05-02 03:40:13] <aniketp41> *will adding
[2018-05-02 03:41:45] <somers_> try it and see
[2018-05-02 09:04:11] * somers_ (~somers@63-224-81-79.hlrn.qwest.net) quit Remote host closed the connection
[2018-05-02 09:05:40] * somers_ (~somers@63-224-81-79.hlrn.qwest.net) join
[2018-05-02 12:21:20] <aniketp41> @somers_, @gnn Generally how long does it take to get a reply back from soc-admins@ ? I'm unable to setup my svn work-area as I don't have an account yet!
[2018-05-02 14:08:10] <aniketp41> Hi @somers_, I've been trying to separate the setup functions from main test program and tried to modify the Makefile to include "SRCS+=setup". But from the errors it seems that the test-program is not able to identify the function declaration in setup.h https://pastebin.com/1CyZii70
[2018-05-02 14:08:46] <aniketp41> Here is the directory organisation within usr/src/tests/sys/audit: https://github.com/aniketp/AuditTestSuite/tree/restructure/src
[2018-05-02 14:16:49] <somers_> you simply forgot to include setup.h in setup.c
[2018-05-02 14:18:48] <aniketp41> Oops, right! Correcting it now
[2018-05-02 14:21:22] <aniketp41> Now it's giving me a bunch of linker errors (same as what I got when I tried independently compiling the tests). Maybe there is an issue with my Makefile, I guess?
[2018-05-02 14:21:22] <aniketp41> Most of the linker error is like this: "undefined reference to `atf_tc_<some-api>"
[2018-05-02 14:22:08] <aniketp41> https://pastebin.com/R7t1JXJw
[2018-05-02 14:23:06] <somers_> Try "SRCS.file-create+=setup" in your Makefile
[2018-05-02 14:26:08] <aniketp41> @somers_, similar error again :/
[2018-05-02 14:26:39] <aniketp41> Is it not able to link to atf-c.h?
[2018-05-02 14:27:06] <somers_> You don't link to header files.  Show me your Makefile and error message
[2018-05-02 14:31:39] <aniketp41> Here is the Makefile: https://github.com/aniketp/AuditTestSuite/blob/restructure/src/Makefile
[2018-05-02 14:31:39] <aniketp41> And the error message after modifying the Makefile: https://pastebin.com/XNABQ9V0
[2018-05-02 14:33:33] <somers_> then try explicitly setting all of SRCS.  "SRCS.file-create=file-create.c setup.c"
[2018-05-02 15:38:45] <gnn> aniketp41: Should be a day or so.
[2018-05-02 15:38:55] <gnn> If more than that email again and cc me again and I'll talk to them.
[2018-05-02 15:39:02] <gnn> They are, as most of us, overworked.
[2018-05-02 16:38:04] <aniketp41> Hi @somers_, I made the change in Makefile, "SRCS.file-create=file-create.c setup.c". The linker issue was gone but it also generated a bunch of new errors. Some of them weirdly pointing to implicit declaration of ATF_TC_* functions. 
[2018-05-02 16:38:04] <aniketp41> Here is the error log: https://pastebin.com/FVBZq4vn
[2018-05-02 16:38:04] <aniketp41> And the code: https://github.com/aniketp/AuditTestSuite/tree/restructure/src
[2018-05-02 16:39:11] <somers_> You forgot to include atf.h
[2018-05-02 16:41:05] <aniketp41> Ohh, I included it in the wrong file again. It should be in file-create.c instead of setup.c. Thanks!
[2018-05-02 16:47:48] <aniketp41> @somers_, Is it alright that I move all includes in setup.h seeing all the fuss which is being created?
[2018-05-02 16:47:48] <aniketp41> Btw the tests are passing again!
[2018-05-02 16:48:37] <somers_> Header bloat is frowned upon.  In FreeBSD, the convention is for file to #include only what it needs.
[2018-05-02 16:50:23] <aniketp41> Okay then I'll have a careful look at what is needed where and move the includes appropriately..
[2018-05-02 17:07:04] <aniketp41> @somers_, I made the appropriate changes in inclusions: Please have a look the current code: https://github.com/aniketp/AuditTestSuite/tree/restructure/src
[2018-05-02 17:09:15] <aniketp41> Also, according to the list of audit_events corresponding to audit_class (fc: file-create), I've made basic test-cases for all 12 syscalls in both failure mode. Shall I create a differential once I get my svn account?
[2018-05-02 17:09:15] <aniketp41> Unless you want me to test some other functionalities of "fc" audit_class before I move on to other classes?
[2018-05-02 17:09:36] <aniketp41> *in both failure and success mode
[2018-05-02 17:09:58] <somers_> please do
[2018-05-02 18:21:00] * somers (~somers@63-224-80-52.hlrn.qwest.net) join
[2018-05-02 18:21:59] * somers_ (~somers@63-224-81-79.hlrn.qwest.net) quit Ping timeout: 252 seconds
[2018-05-02 19:44:46] * somers_ (~somers@63-224-81-246.hlrn.qwest.net) join
[2018-05-02 19:51:12] * somers (~somers@63-224-80-52.hlrn.qwest.net) quit Read error: Operation timed out
[2018-05-03 17:59:47] <aniketp41> Hi @somers_, shall I simply add these files to tests/sys/audit (including the Makefile) while creating a differential? I'm working with a fork of https://github.com/freebsd/freebsd
[2018-05-03 18:00:16] <aniketp41> https://github.com/aniketp/AuditTestSuite/tree/master/src
[2018-05-03 19:39:35] <aniketp41> Ping @somers_
[2018-05-03 20:12:42] <somers_> Yeah, you can add files in a differential revision
[2018-05-03 22:09:30] <aniketp41> Hi @somers_, I created a diff here: https://reviews.freebsd.org/D15286. Please have look. And since this is my first review, please do point out if I messed up somewhere!  
[2018-05-04 15:22:40] <aniketp41> @somers_, what should we do about the non-root issue, since auditpipe does not seem to work here?
[2018-05-04 15:23:35] <somers_> Have you seen anything in the docs about auditing as a non-root user?  Presumably you would be restricted to auditing your own events only.
[2018-05-04 15:30:30] <aniketp41> The doc here https://www.freebsd.org/doc/handbook/audit-administration.html#idp69949288 mentions that the audit trails and the auditpipe(4) is available to the group "audit". I was able to pass the tests when I added myself to that group. Apart from that, I couldn't find any way to access audit facility as a normal user..
[2018-05-04 15:37:06] <somers_> Well, you can certainly skip the tests on the basis of group membership
[2018-05-04 15:37:53] <somers_> Actually, the stuff in /var/audit looks like it's available to group audit, but /dev/auditpipe is only available to root
[2018-05-04 15:43:28] <aniketp41> Oh apologies, the tests produced the same results (bad file descriptor) from audit group too, I guess I must've run the tests as root user, that's how it must have passed (I have SSHd into my VM from two windows, one as root, other as a normal user, so might have inverted the test windows :D )
[2018-05-04 15:43:28] <aniketp41> So, for now, shall I skip the tests for non-root users?
[2018-05-04 15:43:55] <aniketp41> Since no group can actually access /dev/auditpipe..
[2018-05-04 15:44:14] <somers_> Yeah.  Just like you do for the mknod test
[2018-05-04 16:27:24] <aniketp41> Hi @somers_, please have a look at the changes, https://reviews.freebsd.org/D15286
[2018-05-04 22:24:07] * somers__ (~somers@63-224-81-22.hlrn.qwest.net) join
[2018-05-04 22:30:45] * somers_ (~somers@63-224-81-246.hlrn.qwest.net) quit Read error: Operation timed out
[2018-05-05 13:53:06] * somers_ (~somers@63-224-81-175.hlrn.qwest.net) join
[2018-05-05 13:59:58] * somers__ (~somers@63-224-81-22.hlrn.qwest.net) quit Read error: Operation timed out
[2018-05-05 20:11:29] <aniketp41> ping @somers_.
[2018-05-05 22:48:39] <somers_> Hello @aniketp41.  I haven't forgotten about the review
[2018-05-06 23:36:15] <aniketp41> Hi @somers_, I too had the issue of auditpipe(4) not giving any output which resulted in this : "Auditpipe did not return anything within the time limit"
[2018-05-06 23:36:15] <aniketp41> But on doing it again it seemed to work. I figured that was due to auditd(8) not initializing properly
[2018-05-06 23:36:30] <aniketp41> Currently the tests are working on my machine
[2018-05-07 00:31:53] <aniketp41> @somers_, I made the formatting corrections: https://github.com/aniketp/AuditTestSuite/commit/e03991b8d18011615d7c3038926cce86d28dbda4
[2018-05-07 00:31:53] <aniketp41> If these are alright then I'll update the revision?
[2018-05-07 00:32:33] <somers_> auditd doesn't really have anything to do with auditpipe
[2018-05-07 00:33:07] <somers_> maybe there's a race or something
[2018-05-07 00:43:35] <aniketp41> Hmm, weird, the tests were passing for me. The function check_audit() is the heart of this approach and it is called right after triggering the system call we want to audit (as it should be). And since we've already opened "/dev/auditpipe" before the system call, I can't think of a reason auditpipe(4) should miss the syscall trigger. And since we have ATF_REQUIRE check in place, that means the system call was successfully triggered
[2018-05-07 00:43:43] <aniketp41> Unless I'm missing something
[2018-05-07 06:59:23] <rwatson> aniketp41: there's no synchronicity requirement that a syscall only return after the record goes out of the audit pipe, so you might need to insert a short delay after the system call before expecting a record to be emitted from /dev/auditpipe
[2018-05-07 06:59:51] <rwatson> aniketp41: what approach are you using to narrow down the events returned on the audit pipe to try to select only those of interest for capture?
[2018-05-07 09:26:33] <aniketp41> Hi @rwatson, during the initial setup, we've set the local mode preselection parameters to override the system-wide audit mask setting (using this function: https://github.com/aniketp/AuditTestSuite/blob/master/src/utils.c#L91) , i.e "file-create (fc)" in our case. That narrows down to the system call of interest.
[2018-05-07 09:26:33] <aniketp41> Next, we ppoll(2) onto the auditpipe(4) with an infinite loop and set the timeout as 5 seconds. Since, it's highly possible that the first audit_event to be emitted from /dev/auditpipe might not be what we want, so for that we have a check in place which passes the test if we get the desired system call else continue the loop, i.e here: https://github.com/aniketp/AuditTestSuite/blob/master/src/utils.c#L164
[2018-05-07 09:32:15] <aniketp41> Hello @somers_, is it possible that the code which led to the failure of tests in your case might not be the same as mine? Like, an issue while applying the patch.
[2018-05-07 09:32:15] <aniketp41> Cause I've tried many different situations to run the tests, i.e auditd(8) running, not running, root, not root, various combinations of auditd(8) startup right before starting the tests, SSH into VM, directly from VM. All these scenarios produced expected results.
[2018-05-07 09:32:15] <aniketp41> Also, we eliminated the race condition by the infinite loop so theoretically this should work, right?
[2018-05-07 11:00:18] <rwatson> aniketp41: Are you definitely setting it to audit both successful and failed events?
[2018-05-07 11:00:30] <rwatson> it's been quite a long time since I wrote the audit-pipe code. I might need to refresh my memory.
[2018-05-07 11:05:41] <aniketp41> Yes @rwatson, I'm setting both success and failure bits as the required audit_mask
[2018-05-07 11:05:41] <aniketp41> Here is the snippet: https://github.com/aniketp/AuditTestSuite/blob/master/src/utils.c#L145
[2018-05-07 11:06:42] <aniketp41> I used getauclassman(3) as @somers_, suggested, to fetch the audit class mask
[2018-05-07 14:04:14] * somers__ (~somers@63-224-81-231.hlrn.qwest.net) join
[2018-05-07 14:10:32] * somers_ (~somers@63-224-81-175.hlrn.qwest.net) quit Read error: Operation timed out
[2018-05-07 14:12:44] <somers__> @aniketp41 I blew away my tests/sys/audit directory, then recreated it with "arc patch D15286".  So I'm using the same code as what's in the review
[2018-05-07 14:16:29] <aniketp41> Its weird, it passes for me no matter how I test it. I remember the only time it misbehaved was when my audit system spewed non-stop audit records in live-auditing mode (I guess that was because of recursive auditing as I has SSHd)
[2018-05-07 14:25:32] <somers__> It doesn't fail for me 100%.  Last night it was failing.  Today it's passing.  That's why I suspect a race somewhere
[2018-05-07 14:27:26] <aniketp41> @somers__, did the tests fail for both cases, i.e auditd(8) already running and not running?
[2018-05-07 14:27:26] <aniketp41> Cause for me the first test-case failed and by the error message it seemed auditd(8) startup was not poll(2)ed at auditpipe.
[2018-05-07 14:27:26] <aniketp41> But then rest 23 test-cases passed without any issue
[2018-05-07 14:28:12] <aniketp41> *The time I had this issue, everything works fine as of now (hopefully)
[2018-05-07 14:42:56] <somers__> I think there's a bug in the audit filtering mechanism.
[2018-05-07 14:43:28] <somers__> If I remove an audit class from `flags` and `naaflags` in /etc/security/auditcontrol, then do `audit -s`, those events still turn up in the audit log
[2018-05-07 14:43:39] <somers__> (Adding classes seems to work; only removing classes does not)
[2018-05-07 15:20:02] <aniketp41> @somers__, I tried doing the same, but for me "audit -s" does not update the flags whether I remove an audit_class or add it. The changes only take effect when I logout of my SSH session and log back in.
[2018-05-07 15:20:02] <aniketp41>  
[2018-05-07 15:23:12] <somers__> weird; it did the same for me.
[2018-05-07 15:25:37] <aniketp41> @rwatson might have an idea about this issue?
[2018-05-07 15:27:38] <aniketp41> Btw @somers__, I added 24 more test cases (open(2) and openat(2) for various combination of O_RDONLY, O_WRONLY, O_RDWR, O_TRUNC) along with O_CREAT (for "fc": audit class) in both success and failure mode: https://pastebin.com/qP5GR4Pj
[2018-05-07 15:27:53] <aniketp41> Code: https://github.com/aniketp/AuditTestSuite/blob/master/src/file-create.c
[2018-05-07 15:27:59] <somers__> cool
[2018-05-07 15:38:22] <aniketp41> Also, @somers__, since various modes of open(2) are categorized within multiple audit_classes , e.g "74:AUE_OPEN_RT:open(2) - read,trunc:fd,fr,fa,fm", would you suggest I test this particular case for all fd, fr, fa, fm classes or just any random audit_class would do?
[2018-05-07 15:39:23] <somers__> I suppose we probably ought to test them all
[2018-05-09 12:33:32] <aniketp41> Hi @somers__, @rwatson, is there any variant of "copyfile(2)" system call? It was mentioned in the audit_event list but i couldn't find any man-page or info about it..
[2018-05-09 12:33:32] <aniketp41> https://github.com/openbsm/openbsm/blob/master/etc/audit_event#L411
[2018-05-09 13:12:30] <somers__> copyfile is only for OSX.  And it's not a syscall really, just a library function
[2018-05-09 13:15:12] <aniketp41> Okay, so are the man-page sections different for OSX? Cause afaiu, (2) is only for syscalls in FreeBSD.. 
[2018-05-09 13:15:40] <somers__> I don't know how OSX man pages are organized
[2018-05-09 14:21:07] <rwatson> somers__: there is a copyfile(2) system call in XNU
[2018-05-09 14:21:13] <rwatson> somers__: But there is also a library call
[2018-05-09 14:21:31] <rwatson> somers__: the reason for the system call is server-side copy in some distributed filesystems
[2018-05-09 14:21:37] <rwatson> somers__: e.g., AFP and maybe CIFS?
[2018-05-09 14:22:00] <somers__> I see.  But the library call does the work for local filesystems?
[2018-05-09 14:22:15] <rwatson> somers__: I can never remember. :-) I think so, and also for inter-filesystem copies
[2018-05-09 14:22:26] <rwatson> somers__: it's very .. layered
[2018-05-09 14:22:56] <somers__> In any case, it isn't relevant for Aniket's project
[2018-05-09 14:23:01] <rwatson> indeed.
[2018-05-09 14:23:16] <rwatson> I'd focus on freebsd system calls and freebsd userspace parts such as authentication
[2018-05-09 14:23:25] <rwatson> and, of course, on mechanisms such as audit pipes, preselection, etc.
[2018-05-09 14:23:37] <rwatson> but simply iterating over system calls seems a good and productive activity.
[2018-05-09 14:23:46] <somers__> I agree
[2018-05-09 16:12:34] <aniketp41> Hi @somers__, I created 32 more test cases for "file-read" audit class, (mostly "readlink" and "open") :https://github.com/aniketp/AuditTestSuite/blob/master/src/file-read.c
[2018-05-09 16:12:34] <aniketp41> Also would it be right do define those "fileforaudit" strings in "utils.h" since I'll using them in multiple files? Or shall I leave them as it is?
[2018-05-09 16:13:24] <aniketp41> Quite a lot of test-cases already! https://pastebin.com/014VkGG9
[2018-05-09 17:09:17] <somers__> Isn't "fileforaudit" restricted to utils.c?
[2018-05-09 17:16:24] <aniketp41> Nope it's used in test-cases as the "path" 
[2018-05-09 17:16:49] <aniketp41> So it's used in almost every test-case I've developed till now
[2018-05-09 19:01:18] <aniketp41> Ping @somers__. Is there anything left to do with D15286? I was thinking of opening another differential as know I have more than triple the test-cases. And I guess reviewing them might also take a bit of time..
[2018-05-09 19:01:26] <aniketp41> *now
[2018-05-09 19:01:56] <somers__> We can't commit D15286 until we solve the intermittency bug
[2018-05-09 19:02:39] <somers__> If you understand the bug well enough that you can cause it to fail 100% of the time, then we can commit tests with "atf_expect_fail" statements.  But we can't commit intermittent tests.
[2018-05-09 19:18:08] <aniketp41> So @somers__, in that scenario what should be the best approach for me? Shall I keep adding tests or try to figure out the issue. Do you think it can be resolved without much hassle?
[2018-05-09 19:20:01] <somers__> Well, it seems fairly easy to reproduce.  For me, it seems to happen whenver I boot with the default /etc/security/audit_control.  I can make it go away by adding fc to the flags in audit_control, and the bug does not return when I revert audit_control (even if I do audit -s).
[2018-05-09 19:20:22] <somers__> However, the bug likely lies in the kernel.  Want to learn some kernel programming?
[2018-05-09 19:25:58] <aniketp41> I tried my hands on writing device drivers once, but was quite unsuccessful. I can try but I'm not too sure if I can get it right :D 
[2018-05-09 19:34:23] <aniketp41> @somers__, I set "flags:nt" in audit_control, confirmed that network events were being emitted from auditpipe, rebooted the VM and ran the tests, it seemed to work somehow. 
[2018-05-09 19:35:14] <aniketp41> Btw, what flags did you have in your default audit_control?
[2018-05-09 19:35:51] <somers__> You shouldn't need to set those flags in /etc/security/audit_control, because we're overriding them with AUDITPIPE_SET_PRESELECT_FLAGS
[2018-05-09 19:37:25] <aniketp41> But @somers__, you said that adding "fc" to /etc/security/audit_control seemed to pass the tests for you? So isn't it being affected by the audit_control file? 
[2018-05-09 19:37:35] <somers__> Hm, I wonder if the problem is because you don't do AUDITPIPE_SET_PRESELECT_NAFLAGS
[2018-05-09 19:37:50] <somers__> It is, but it shouldn't be.  That's the bug.
[2018-05-09 19:39:37] <aniketp41> @somers__, I'll try adding "AUDITPIPE_SET_PRESELECT_NAFLAGS" too but at the moment I'm not able to reproduce the bug.. It just happened once a while back but never again. 
[2018-05-09 19:39:55] <somers__> ok.  I'll try it out once you update the review
[2018-05-09 19:50:09] <aniketp41> @somers__, Is it possible that auditpipe(4) does not emit "audit startup" for the very first test-case?
[2018-05-09 19:50:09] <aniketp41> I got this weird issue for the first time: https://pastebin.com/V8caGFww
[2018-05-09 19:50:53] <aniketp41> I had "praudit /dev/auditpipe" running in an other window and it did not output anything for link_failure case, as expected because of that issue
[2018-05-09 19:51:43] <somers__> What's weird about it?  That just means that get_records returned false
[2018-05-09 19:54:07] <aniketp41> That means "audit startup" string was not found in the memstream, so audit startup was not logged right? Or does it signify something else? 
[2018-05-09 19:55:08] <aniketp41> Cause the one time I had an issue was that I got "Poll: auditpipe did not return anything within the time limit" for every system call. 
[2018-05-09 20:26:19] <somers__> Yep
[2018-05-09 20:46:33] <aniketp41> So @somers__, are such kind of errors (which I just got, but it seems to have gone away again) allowed with Kyua philosophy?
[2018-05-09 20:46:33] <aniketp41> Also, I updated the differential: https://reviews.freebsd.org/D15286
[2018-05-09 21:11:30] <somers__> What "Kyua philosophy"?
[2018-05-09 21:15:29] <aniketp41> As in, is the error acceptable?
[2018-05-09 21:35:21] <somers__> It's not ok for a test to intermittenly fail, if that's what you're asking
[2018-05-09 21:38:25] <somers__> I think the NAFLAGS change fixed the tests's intermittency
[2018-05-09 21:48:28] <aniketp41> Quite cool! I'll remove the curly braces and update the diff
[2018-05-09 21:58:20] <aniketp41> @somers__ updated, https://reviews.freebsd.org/D15286
[2018-05-09 22:13:24] <aniketp41> @somers__ how are you able to segregate the tabs and spaces? I have set 8 hard width tab in my IDE but sometimes when I'm editing it on the fly with some other editors I miss the tab requirement..
[2018-05-09 22:13:35] <aniketp41> *between
[2018-05-09 22:13:59] <aniketp41> It's also hard to notice the difference and spot the mistake
[2018-05-09 22:14:33] <somers__> In vim, I used this search string to find errant space indentation: "^\t*  "
[2018-05-09 22:46:40] <aniketp41> @somers__, the tests seemed to work without this line: "SRCS.file-create+= file-create.c"
[2018-05-09 22:47:00] <aniketp41> i.e, it worked with simply: SRCS.file-create+= utils.c
[2018-05-09 22:51:48] <somers__> Makes sense
[2018-05-09 22:57:41] <aniketp41>  Okay I'll update the differential
[2018-05-09 23:00:19] <somers__> I think I figured out why you were getting the errors in check_audit_startup
[2018-05-09 23:00:36] <somers__> It's because the preselect mask wasn't set to include class "ad", which is the class for the "audit startup" messages.
[2018-05-09 23:05:04] <aniketp41> Oh, right! this one -> https://github.com/openbsm/openbsm/blob/master/etc/audit_event#L674
[2018-05-09 23:05:15] <somers__> Unfortunately, when I try to include it, I get a reproducible panic:
[2018-05-09 23:05:21] <somers__> panic: Bad tailq NEXT(0xfffff80047450ec8->tqh_last) != NULL
[2018-05-09 23:05:22] <somers__> cpuid = 1
[2018-05-09 23:05:22] <somers__> time = 1525906488
[2018-05-09 23:05:22] <somers__> KDB: stack backtrace:
[2018-05-09 23:05:22] <somers__> db_trace_self_wrapper() at db_trace_self_wrapper+0x2b/frame 0xfffffe00264488a0
[2018-05-09 23:05:22] <somers__> vpanic() at vpanic+0x18d/frame 0xfffffe0026448900
[2018-05-09 23:05:24] <somers__> panic() at panic+0x43/frame 0xfffffe0026448960
[2018-05-09 23:05:26] <somers__> kaudit_to_bsm() at kaudit_to_bsm+0x5265/frame 0xfffffe0026448a10
[2018-05-09 23:05:28] <somers__> audit_worker() at audit_worker+0x30d/frame 0xfffffe0026448a70
[2018-05-09 23:05:30] <somers__> fork_exit() at fork_exit+0x84/frame 0xfffffe0026448ab0
[2018-05-09 23:05:32] <somers__> fork_trampoline() at fork_trampoline+0xe/frame 0xfffffe0026448ab0
[2018-05-09 23:05:42] <somers__> I'll update my VM and try to figure out what's going on.
[2018-05-09 23:06:20] <aniketp41> Are these kernel errors? I haven't seen them before..
[2018-05-09 23:06:31] <aniketp41> Oh I understand now, kernel panic
[2018-05-09 23:08:31] <aniketp41> @somers__, do I need to to add preselection flag as "ad" for audit startup. I guess I can "OR" it with the audit mask I'm passing as the argument
[2018-05-09 23:10:44] <somers__> Yes, that's what I think you should do.
[2018-05-09 23:11:48] <aniketp41> Okay on it! I guess I'll need to tweak the order of the code of "utils.c"
[2018-05-09 23:17:01] <aniketp41> Btw, @somers__, is it allowed to set the local preselection flags once then change them later on in the same program?
[2018-05-09 23:17:01] <aniketp41> Cause I was wondering that if we really need to set "fd" when auditd(8) was already running.. 
[2018-05-09 23:17:17] <aniketp41> *ad
[2018-05-09 23:17:40] <somers__> No, because if auditd(8) is already running, then we don't need to check for auditd startup
[2018-05-09 23:17:47] <somers__> But it won't hurt.
[2018-05-10 12:31:23] <aniketp41> @somers__, I tried what you suggested, taking a bitwise OR of "class" and "ad" and then calling the function "set_preselect_mode" before audit_startup, so that we've basically converted the audit_startup_check to local mode with "fc | ad" flags. 
[2018-05-10 12:31:23] <aniketp41> But it looks like audit of audit_startup doesn't work in local mode. 
[2018-05-10 12:31:23] <aniketp41> i.e here are the changes in two functions: https://pastebin.com/usn7R72U  
[2018-05-10 12:32:46] <aniketp41> This time, the tests pass when auditd(8) is already running but get this: "get_records(auditstring, pipestream) not met" when it needs to be started from out program
[2018-05-10 12:32:55] <aniketp41> *our
[2018-05-10 15:25:35] <somers__> Hey Aniket.  What FreeBSD release are you using?
[2018-05-10 15:25:45] <somers__> ping @aniketp41
[2018-05-10 15:47:01] <aniketp41> uname -a gives: "11.1-RELEASE-p4"
[2018-05-10 15:47:31] <aniketp41> I got the latest VM image that @gnn had given me initially
[2018-05-10 15:48:21] <somers__> That's why you didn't see the panic that I did
[2018-05-10 15:48:37] <somers__> I'm using 12.0-CURRENT, which has extra sanity checks enabled
[2018-05-10 15:53:48] <aniketp41> Oh I see, I'm using the same VM image since the time I started using FreeBSD, so never had to update it
[2018-05-10 15:53:48] <aniketp41> Btw does it fix the issue of non-emitting of "audit_startup" in auditpipe(4)?
[2018-05-10 15:54:06] <somers__> nope.  I'm looking at that one now
[2018-05-10 15:54:42] <somers__> And BTW, 12.0-CURRENT isn't on the upgrade path from 11.1-RELEASE.  12.0-CURRENT is the bleeding edge image built from SVN head.  It's never officially released
[2018-05-10 16:03:37] <somers__> Uh, it looks like the preselect filters are working fine, but you get a few extra events before "audit startup"
[2018-05-10 16:05:13] <somers__> So I think you just need to loop in check_audit_startup
[2018-05-10 16:08:28] <aniketp41> Okay, so I essentially need to do the similar stuff as in "check_audit" function, right? somers__
[2018-05-10 16:08:37] <somers__> yep
[2018-05-10 16:08:55] <aniketp41> Okay, on it!
[2018-05-10 16:36:34] <aniketp41> Yes @somers__, the looping worked! So basically I reused "check_audit" in case of changing the "check_audit_startup" (as the code is same in both) and changed a bit of logic. Instead of while(true), I'm doing while("a variable") which is initialized by 1. When get_records() returns true, I'm changing the variable to 0, to end the while loop. (As I can't do "atf_tc_pass()" for audit checkup)
[2018-05-10 16:36:51] <aniketp41> *in case -> instead
[2018-05-10 16:41:14] <somers__> makes sense.  Is it ready for review?
[2018-05-10 17:00:00] <aniketp41> Just a sec. Making some final changes
[2018-05-10 17:03:54] <aniketp41> @somers__, there was one small issue. Since I'm doing two rounds of "check_audit" now, I can't close the file descriptors in that function as doing that after first round would fail the tests. Is there any work-around this?
[2018-05-10 17:04:20] <aniketp41> Like passing another boolean argument to "check_audit"
[2018-05-10 17:05:36] <somers__> How about check_audit and check_startup are both wrappers around a static function that has such as boolean argument.  That way you won't be exposing an argument to the test cases that they'll never use.
[2018-05-10 17:09:41] <aniketp41> So do you mean having three functions, where check_audit and check_startup would call another function while passing them a boolean argument?
[2018-05-10 17:16:19] <aniketp41> ping @somers__ 
[2018-05-10 17:16:44] <somers__> yeah.  Makes the API cleaner
[2018-05-10 17:35:56] <aniketp41> Hi @somers__, updated the diff!
[2018-05-10 17:35:56] <aniketp41> Also, had to add back the line "SRCS.file-create+= file-create.c" as apparently the linker issue persists without it. (Earlier I overlooked this somehow)
[2018-05-10 17:49:08] <aniketp41> @somers__, Isn't "am_failure" required as I'm also testing the failure mode of every syscall? 
[2018-05-10 17:49:52] <aniketp41> Oh, not for auditd(8), I see
[2018-05-10 17:49:57] <somers__> am_failure is required for the fc class, but not for ad
[2018-05-10 17:52:41] <aniketp41> Also, @somers__, since I'll move the cleanup part into "check_audit", I can remove the boolean arguments, right? As I don't need them anymore 
[2018-05-10 17:52:59] <somers__> yeah
[2018-05-10 17:56:18] <aniketp41> @somers__, would replacing checkpoint variable with break, break out of the loop? As it now produces a new error for every test-case:
[2018-05-10 17:56:18] <aniketp41> "failed: Incomplete audit record"
[2018-05-10 17:56:33] <aniketp41> I guess it's just breaking out of the switch statement
[2018-05-10 17:56:51] <aniketp41> I guess it's just breaking out of the switch statement
[2018-05-10 17:57:16] <somers__> If so, you can break out of the loop with a goto
[2018-05-10 18:02:19] <aniketp41> Isn't goto discouraged? I mean, also there isn't any specific location where I can make it jump. And if I make it jump at the end, then there isn't any code there too.
[2018-05-10 18:05:30] <aniketp41> ping @somers__, I thought that checkpoint method looked fine
[2018-05-10 18:06:43] <somers__> goto is allowed when it's better than any alternative.  This is the kind of place where it gets used in FreeBSD.  Other languages allow you to break out of nested loops, but not C.  So C programmers use goto in this place
[2018-05-10 18:06:54] <somers__> And if you just need to go to the end, then you can simply use return
[2018-05-10 18:10:43] <aniketp41> Okay @somers__, so I was for some reason not able to get goto to work hence I simply put a "return" there, as you suggested. (Since we don't need anything else from that function anymore)
[2018-05-10 18:11:01] <aniketp41> *(after we've reached that point)
[2018-05-10 18:11:17] <somers__> that's fine
[2018-05-10 19:14:28] <somers__> @aniketp41 none of the tests pass in your latest version
[2018-05-10 19:16:00] <aniketp41> Yes the tests fail for me when auditd is already running. But when I placed "set_preselect_mode" after auditd startup, they did pass however
[2018-05-10 19:16:12] <aniketp41> @somers__ 
[2018-05-10 19:16:52] <somers__> And you knew this?  Why did you upload a new revision to Phabricator if the tests don't pass?
[2018-05-10 19:18:44] <aniketp41> No I just checked. I hadn't confirmed the tests in the case when auditd(8) was already running. 
[2018-05-10 19:19:10] <aniketp41> As earlier we only had issues with tests for audit startup
[2018-05-10 19:21:44] <aniketp41> @somers__ 
[2018-05-10 19:22:00] <somers__> yes?
[2018-05-10 19:38:46] <aniketp41> @somers__, I placed "set_preselect_mode" after auditd(8) startup and now the tests are passing in both scenarios. I'll update the diff accordingly.
[2018-05-10 19:38:46] <aniketp41> Although what should we do about the race condition as you mentioned in the diff, as resolving that makes the test cases fail
[2018-05-10 19:44:27] <somers__> Why do they fail when set_preselect_mode is early?
[2018-05-10 19:56:20] <aniketp41> @somers__, The error is: "Auditpipe did not return anything within the time limit" when auditd(8) is already running. But everything works fine when we have to start it from our program. I guess, maybe "service auditd onestatus" has something to do with it. 
[2018-05-10 19:56:58] <somers__> It shouldn't.  You should try to figure out what's going on.
[2018-05-10 20:04:31] <aniketp41> Okay @somers__, BTW do they fail for you?
[2018-05-10 20:07:32] <somers__> The revision you posted at 12:15 PM MDT fails for me, whether or not auditd is started
[2018-05-10 20:14:38] <aniketp41> Okay @somers__., so I had updated the revision about 1.5 hours after that. Can you please check if that fails for you as well?  
[2018-05-10 20:14:38] <aniketp41> Current revision passes for me in both scenarios. But I also had to place "set_preselect_mode" after auditd startup.
[2018-05-10 20:14:38] <aniketp41> If the current revision passes for you then we can be sure that the placement of that function caused the issue
[2018-05-10 20:16:54] <somers__> When I move it as you suggest, all the tests pass if auditd is already running.  If it isn't, then most (but not all) tests fail.
[2018-05-10 20:26:04] <aniketp41> Hmm, I tried out the tests multiple times, it looks the only problem I'm having is when auditd(8) is running and "set_preselect_mode" is placed before audit startup. In all other cases, all tests pass for me. Not sure why some of them fail for you.
[2018-05-10 20:26:04] <aniketp41> But the placement of the function is causing an issue. Would it be alright if I place it after the audit startup? As I can't seem to understand any race condition here. On the contrary, fixing the race condition causes the issue for sure..
[2018-05-10 20:27:40] <somers__> There's a difference between fixing a race and winning a race.  With set_preselect_mode after auditd startup, you're winning the race.  That's bad.
[2018-05-10 20:28:06] <somers__> We can't commit this until the race is eliminated, and that means you need to understand why the tests fail when you do set_preselect_mode early.
[2018-05-10 21:05:47] <aniketp41> Hi @somers__, I found out the issue. "system("service auditd onestatus");" was causing the problem. When I inserted AUDITPIPE_FLUSH after the auditd startup, the tests passed. 
[2018-05-10 21:05:47] <aniketp41> Have a look at this code: https://pastebin.com/GgnNpkd1
[2018-05-10 21:10:26] <somers__> so what was going on?
[2018-05-10 21:13:23] <somers__> "service auditd onestatus" basically just does "ps -ww".  It doesn't do anything particular to audit(4)
[2018-05-10 21:13:27] <aniketp41> I'm not sure, I thought that maybe inclusion of "ad" had to do with this but even after I removed it from au_mask, it still did not pass the test. The only conclusion I have is that "system()" call changes some properties of auditon(2) which renders our local mode auditing useless 
[2018-05-10 21:16:22] <somers__> From the description of AUDITPIPE_FLUSH, it doesn't sound like it would be relevant
[2018-05-10 21:28:44] <aniketp41> @somers__, does it have to do anything with AUDITPIPE_QLIMIT? I know it doesn't make any sense but this is the most probable explanation I could come up with: Since moving "set_preselect_mask" about "system("service auditd onestatus")" made the tests to pass/fail, and since the system call we desired wasn't coming out of auditpipe, it could mean that auditpipe's maximum limit was reached, and that using "AUDITPIPE_FLUSH" cleaned it up. 
[2018-05-10 21:28:44] <aniketp41> I found this in the man-page of auditpipe(4): "In particular, when an audit pipe queue fills, records will be dropped."
[2018-05-10 21:46:48] <somers__> that would make sense
[2018-05-10 21:46:59] <somers__> You can prove it by checking AUDITPIPE_GET_QLEN
[2018-05-10 21:48:39] * somers_ (~somers@63-224-80-166.hlrn.qwest.net) join
[2018-05-10 21:55:24] * somers__ (~somers@63-224-81-231.hlrn.qwest.net) quit Read error: Operation timed out
[2018-05-10 22:28:43] <aniketp41> I did an independent experiment for this. AUDITPIPE_GET_QLEN returned "1" when auditd was already running and "3" when it had to be started?
[2018-05-10 22:29:02] <aniketp41> So is this fix legitimate? As in, shall I update the differential?
[2018-05-10 22:29:12] <aniketp41> ping @somers_ 
[2018-05-10 22:30:24] <somers_> Only 3?  It would be very surprising if the limit were that low.
[2018-05-10 22:34:20] <aniketp41> @somers_, here is the makeshift code I used: https://pastebin.com/akTduSVk
[2018-05-10 22:37:05] <somers_> I think you're checking the qlen in the wrong place.  The hypothetical failure condition is that the queue fills up before the test calls check_audit.  So you should check the queue depth at that point, and compare it to the limit
[2018-05-10 22:43:40] <aniketp41> @somers_, so I included random "fc" system calls before checking QLEN, it seems as if each event increases QLEN by 1. While QLIMIT was 128
[2018-05-10 22:43:40] <aniketp41> Have a look at this code and its output: https://pastebin.com/AtVHit1w
[2018-05-10 22:44:04] <aniketp41> QLIMIT seems to be much more than the number of queued events
[2018-05-10 22:45:00] <somers_> But this is just a toy program.  In your real test case, Kyua also creates a bunch of auditable events
[2018-05-10 22:46:08] <aniketp41> Yes, that makes sense. I was monitoring "praudit /dev/auditpipe" from another window while running the test cases, there were huge number of "openat(2)" system calls alongwith the main syscall
[2018-05-10 22:47:48] <aniketp41> So @somers_, will this fix do? Or is there something else that I need to take care of?
[2018-05-10 22:49:01] <somers_> We still aren't 100% sure that this FLUSH fixes the real problem.  I think you need to disable the flush, then check the QLEN after generating all auditable events but before reading from the auditpipe in check_audit
[2018-05-10 22:55:04] <aniketp41> @somers_, But does Kyua let me print values to STDOUT? Or should I just compare QLEN with QLIMIT?
[2018-05-10 22:55:28] <somers_> Sure.  You can printf to your heart's content
[2018-05-11 08:53:45] <rwatson> aniketp41: Note that FLUSH only flushes the current audit pipe's buffer, not the audit event queue from system-call commit
[2018-05-11 08:54:12] <rwatson> aniketp41: I believe if you update selection rules, and flush, you should then only see records after the flush returns that conform to the rules
[2018-05-11 08:54:16] <rwatson> aniketp41: if this is not the case, we may have a bug
[2018-05-11 11:51:43] <aniketp41> Yes @rwatson, flush worked as it is supposed to, we were only getting the audit_events corresponding to the flag & naflag we had set earlier, after flush returns. The issue was that what Q_LEN returned is way less than Q_LIMIT (contrary to what we expected)
[2018-05-11 11:53:22] <aniketp41> Hi @somers_, I placed a ioctl function to return Q_LEN and Q_LIMIT right before we call check_audit(): https://pastebin.com/nEsVnLju
[2018-05-11 11:53:45] <aniketp41> But even now Q_LEN returns 2, (I had removed the flush part earlier)
[2018-05-11 11:54:55] <aniketp41> Note: I couldn't get printf() to show anything on stdout so instead I set the breakpoint as atf_tc_fail() which returned the value of "apple"
[2018-05-11 11:59:07] <aniketp41> My take here is: we've used clock_gettime() a lot of times and it's complement : clock_settime(2) was listed as "ad". So is it possible that clock_gettime fills up the queue?
[2018-05-11 14:24:35] <somers_> @aniketp41 Kyua suppresses stdout from passing test cases.  If you want to see stdout, you can do "kyua debug test_program:test_case"
[2018-05-11 14:38:09] <somers_> Just add this code to check_audit and you will see that the queue does indeed fill up when set_preselect_mode comes before starting auditd:
[2018-05-11 14:38:16] <somers_> void
[2018-05-11 14:38:16] <somers_> check_audit(struct pollfd fd[], const char *auditrgx, FILE *pipestream) {
[2018-05-11 14:38:16] <somers_> 	int qlimit, qlen;
[2018-05-11 14:38:16] <somers_> 	ioctl(fd[0].fd, AUDITPIPE_GET_QLIMIT, &qlimit);
[2018-05-11 14:38:16] <somers_> 	ioctl(fd[0].fd, AUDITPIPE_GET_QLEN, &qlen);
[2018-05-11 14:38:16] <somers_> 	printf("qlen=%d qlimit=%d\n", qlen, qlimit);
[2018-05-11 14:38:18] <somers_> 	check_auditpipe(fd, auditrgx, pipestream);
[2018-05-11 14:38:20] <somers_> 	/* Cleanup */
[2018-05-11 14:38:22] <somers_> 	fclose(pipestream);
[2018-05-11 14:38:24] <somers_> 	close(fd[0].fd);
[2018-05-11 14:38:26] <somers_> }
[2018-05-11 14:38:43] <somers_> Adding the AUDITPIPE_FLUSH at the end of setup fixes the queue length issue, but reveals another problem
[2018-05-11 15:00:01] <aniketp41> @somers_, I added this code snippet to check_audit() and kyua debug provided a good insight into what was actually going on. However, qlen still returns 2 to me. https://pastebin.com/7dkRXnFh
[2018-05-11 15:03:25] <somers_> Did you put set_preselect_mode *before* starting auditd?
[2018-05-11 15:05:14] <aniketp41> Yes @somers_, here is my setup function: https://pastebin.com/W9YnbqCr
[2018-05-11 15:15:56] <aniketp41> Also @somers_, the part where test fails: "when auditd is already running and we don't have any AUDITPIPE_FLUSH", I was also checking the /dev/auditpipe from another window and it seems that "kyua debug" only checks till an openat(2) function which occurs right before "mkdir(2)". 
[2018-05-11 15:16:55] <somers_> You can't check "the auditpipe" from another window.  Every time you open /dev/auditpipe, you're getting a unique device with potentially different configuration
[2018-05-11 15:17:31] <somers_> Kyua will keep reading from auditpipe until your test case either passes or fails; you're in total control of that
[2018-05-11 15:18:39] <aniketp41> Yes so my global config is flag:"fc" and mkdir(2) was being audited there. Not sure why the auditpipe opened from program failed. It's like it was stuck right before mkdir(2) call.  
[2018-05-11 15:20:32] <somers_> The default audit_control configuration is to have both flags and naflags set to "lo,aa".  That's how the test will most often be run, and that's where you should be focusing your efforts too
[2018-05-11 15:22:05] <aniketp41> Okay @somers_, btw was "qlen" equal to "qlimit" in your case? 
[2018-05-11 15:22:31] <somers_> Yes, at 128
[2018-05-11 15:50:15] <aniketp41> @somers_ It still shows qlen=2 for me everytime, and I added few miscellaneous events just to confirm if qlen returns anything other than 2, and it was showing certain increase in its value. However, it never reaches 128.
[2018-05-11 15:50:15] <aniketp41> Is it possible that our code utils.c is different?
[2018-05-11 15:50:15] <aniketp41> Although, I'm also using a variant of the one which is in the current diff
[2018-05-11 15:57:16] <aniketp41> Btw @somers_, you mentioned that this fix reveals another problem. What was it?
[2018-05-11 15:57:48] <somers_> When I add the flush, the test fails with this error, whether or not auditd is already running:
[2018-05-11 15:57:56] <somers_> file-create:symlinkat_success  ->  failed: Incomplete audit record
[2018-05-11 16:00:46] <aniketp41> Was it for this particular case or did all tests fail?
[2018-05-11 16:19:01] <somers_> With auditd stopped, all test cases fail
[2018-05-11 16:27:39] <somers_> But at least 1 is intermittent
[2018-05-11 19:40:38] <aniketp41> Hello @somers_, can you please run the tests again? I've updated the revision. This time, it looks as if the intermittent issue is (hopefully) gone. I also might have found a similar problem in bsmtrace code
[2018-05-11 19:41:08] <somers_> will do
[2018-05-11 20:11:14] <somers_> Now, when audit isn't already running, about 25% of the tests pass and the rest timeout.  But it's a different 25% each time.
[2018-05-11 20:21:21] <aniketp41> @somers_, Not sure why the tests fail for you. I did have a few intermittent audit incomplete errors earlier but now I've tried various things, i.e rebooting my VM and quickly running the tests again but they never seem to fail. I also pushed the limits by running three instances of tests but it passed even then.
[2018-05-11 23:05:35] <aniketp41> Hi @somers_, what should be the course of action now, since we've got conflict in test results?
[2018-05-11 23:06:02] <somers_> You need to figure out why they sometimes time out
[2018-05-11 23:06:27] <somers_> And why you get the "incomplete record" errors
[2018-05-11 23:12:40] <aniketp41> @somers, I haven't been getting any timeout errors recently. I'm not sure how I'd reproduce those errors back. And the "incomplete audit records" errors occur when au_fetch_tok returns "-1". One issue I could come up with was the "reclen-bytes" might be less than "token.len" but you said that it was not possible. So I'm  kind of stuck here..
[2018-05-11 23:12:58] <aniketp41> @somers_ 
[2018-05-11 23:14:07] <somers_> You can look at the implementation of au_fetch_tok and au_read_rec to gain insights about the "incomplete audit record" error.
[2018-05-11 23:14:11] <somers_> It's in contrib/openbsm
[2018-05-12 14:27:15] <aniketp41> Hello @somers_, I had been looking at the code of "au_fetch_tok" and all the subsequent "fetch_header**tok" functions it calls and it looks like the only time it returns (-1) is when the length of a given token (tok->len) along with sizeof(u_int**_t) is more than the third argument of au_fetch_tok(), i.e "reclen  - bytesread". 
[2018-05-12 14:27:15] <aniketp41> Which probably should be the case with the "incomplete audit record" errors you've been getting. 
[2018-05-12 14:31:24] <aniketp41> When I replaced "reclen - bytesread" with "reclen" it seemed to fix the issue since we're never reducing the "len" argument and that length of the entire audit record will obviously be more than any particular token. So the error condition never happened then
[2018-05-12 14:33:27] <aniketp41> I'm not getting timeout errors anymore, but it looks like this might again be similar to what we were getting initially, and that introduction of "AUDITPIPE_FLUSH" seemed to correct it. This time I think maybe placing AUDITPIPE_FLUSH right before calling "check_audit" might help?
[2018-05-12 15:34:04] <aniketp41> ping @somers_ 
[2018-05-12 15:53:06] <somers_> You may not increase the length of au_fetch_tok's third argument beyond the size of the buffer you supply to it.  Buffer overflows are not ok.
[2018-05-12 16:14:01] <aniketp41> Then @somers_, is it possible that au_read_rec might not return the exact length of audit record? That might explain why sometimes "reclen - bytesread" is not greater than or equal to "tok.len"
[2018-05-12 16:14:12] <aniketp41> As in, a bug in that function?
[2018-05-12 16:15:01] <aniketp41> I found this comment by @rwatson here: /*-
[2018-05-12 16:15:01] <aniketp41>  * Copyright 2018 Aniket Pandey
[2018-05-12 16:15:01] <aniketp41>  * All rights reserved.
[2018-05-12 16:15:01] <aniketp41>  *
[2018-05-12 16:15:01] <aniketp41>  * Redistribution and use in source and binary forms, with or without
[2018-05-12 16:15:01] <aniketp41>  * modification, are permitted provided that the following conditions
[2018-05-12 16:15:01] <aniketp41>  * are met:
[2018-05-12 16:15:01] <aniketp41>  * 1. Redistributions of source code must retain the above copyright
[2018-05-12 16:15:01] <aniketp41>  *    notice, this list of conditions and the following disclaimer.
[2018-05-12 16:15:01] <aniketp41>  * 2. Redistributions in binary form must reproduce the above copyright
[2018-05-12 16:15:01] <aniketp41>  *    notice, this list of conditions and the following disclaimer in the
[2018-05-12 16:15:01] <aniketp41>  *    documentation and/or other materials provided with the distribution.
[2018-05-12 16:15:01] <aniketp41>  *
[2018-05-12 16:15:01] <aniketp41>  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
[2018-05-12 16:15:01] <aniketp41>  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
[2018-05-12 16:15:01] <aniketp41>  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
[2018-05-12 16:15:01] <aniketp41>  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
[2018-05-12 16:15:01] <aniketp41>  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
[2018-05-12 16:15:01] <aniketp41>  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
[2018-05-12 16:15:01] <aniketp41>  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
[2018-05-12 16:15:01] <aniketp41>  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
[2018-05-12 16:15:01] <aniketp41>  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
[2018-05-12 16:15:01] <aniketp41>  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
[2018-05-12 16:15:01] <aniketp41>  * SUCH DAMAGE.
[2018-05-12 16:15:01] <aniketp41>  *
[2018-05-12 16:15:01] <aniketp41>  * $FreeBSD$
[2018-05-12 16:15:01] <aniketp41>  */
[2018-05-12 16:15:01] <aniketp41> #include <sys/ioctl.h>
[2018-05-12 16:15:01] <aniketp41> #include <time.h>
[2018-05-12 16:15:01] <aniketp41> #include <errno.h>
[2018-05-12 16:15:01] <aniketp41> #include <fcntl.h>
[2018-05-12 16:15:01] <aniketp41> #include <atf-c.h>
[2018-05-12 16:15:01] <aniketp41> #include <string.h>
[2018-05-12 16:15:01] <aniketp41> #include <stdlib.h>
[2018-05-12 16:15:01] <aniketp41> #include <unistd.h>
[2018-05-12 16:15:01] <aniketp41> #include <bsm/libbsm.h>
[2018-05-12 16:15:01] <aniketp41> #include <security/audit/audit_ioctl.h>
[2018-05-12 16:15:01] <aniketp41> #include "utils.h"
[2018-05-12 16:15:01] <aniketp41>  * Checks the presence of "auditregex" in auditpipe(4) after the
[2018-05-12 16:15:01] <aniketp41>  * corresponding system call has been triggered.
[2018-05-12 16:15:01] <aniketp41>  */
[2018-05-12 16:15:01] <aniketp41> static bool
[2018-05-12 16:15:01] <aniketp41> get_records(const char *auditregex, FILE *pipestream)
[2018-05-12 16:15:01] <aniketp41> {
[2018-05-12 16:15:01] <aniketp41> 	uint8_t *buff;
[2018-05-12 16:15:01] <aniketp41> 	tokenstr_t token;
[2018-05-12 16:15:01] <aniketp41> 	ssize_t size = 1024;
[2018-05-12 16:15:01] <aniketp41> 	char membuff[size];
[2018-05-12 16:15:01] <aniketp41> 	char del[] = ",";
[2018-05-12 16:15:01] <aniketp41> 	int reclen, bytes = 0;
[2018-05-12 16:15:01] <aniketp41> 	FILE *memstream;
[2018-05-12 16:15:01] <aniketp41> 	/*
[2018-05-12 16:15:01] <aniketp41> 	 * Open a stream on 'membuff' (address to memory buffer) for storing
[2018-05-12 16:15:01] <aniketp41> 	 * the audit records in the default mode.'reclen' is the length of the
[2018-05-12 16:15:01] <aniketp41> 	 * available records from auditpipe which is passed to the functions
[2018-05-12 16:15:01] <aniketp41> 	 * au_fetch_tok(3) and au_print_flags_tok(3) for further use.
[2018-05-12 16:15:01] <aniketp41> 	 */
[2018-05-12 16:15:01] <aniketp41> 	memstream = fmemopen(membuff, size, "w");
[2018-05-12 16:15:01] <aniketp41> 	reclen = au_read_rec(pipestream, &buff);
[2018-05-12 16:15:01] <aniketp41> 	/*
[2018-05-12 16:15:01] <aniketp41> 	 * Iterate through each BSM token, extracting the bits that are
[2018-05-12 16:15:01] <aniketp41> 	 * required to start processing the token sequences.
[2018-05-12 16:15:01] <aniketp41> 	 */
[2018-05-12 16:15:01] <aniketp41> 	while (bytes < reclen) {
[2018-05-12 16:15:01] <aniketp41> 		if (au_fetch_tok(&token, buff + bytes, reclen) == -1)
[2018-05-12 16:15:01] <aniketp41> 			atf_tc_fail("Incomplete audit record");
[2018-05-12 16:15:01] <aniketp41> 		/* Print the tokens as they are obtained, in the default form */
[2018-05-12 16:15:01] <aniketp41> 		au_print_flags_tok(memstream, &token, (char *)del, AU_OFLAG_NONE);
[2018-05-12 16:15:01] <aniketp41> 		bytes += token.len;
[2018-05-12 16:15:01] <aniketp41> 	}
[2018-05-12 16:15:01] <aniketp41> 	free(buff);
[2018-05-12 16:15:01] <aniketp41> 	fclose(memstream);
[2018-05-12 16:15:01] <aniketp41> 	return (atf_utils_grep_string("%s", membuff, auditregex));
[2018-05-12 16:15:01] <aniketp41> }
[2018-05-12 16:15:01] <aniketp41>  * Override the system-wide audit mask settings in /etc/security/audit_control
[2018-05-12 16:15:01] <aniketp41>  */
[2018-05-12 16:15:01] <aniketp41> static void
[2018-05-12 16:15:01] <aniketp41> set_preselect_mode(int filedesc, au_mask_t *fmask)
[2018-05-12 16:15:01] <aniketp41> {
[2018-05-12 16:15:01] <aniketp41> 	int fmode = AUDITPIPE_PRESELECT_MODE_LOCAL;
[2018-05-12 16:15:01] <aniketp41> 	/* Set local preselection mode for auditing */
[2018-05-12 16:15:01] <aniketp41> 	if (ioctl(filedesc, AUDITPIPE_SET_PRESELECT_MODE, &fmode) < 0)
[2018-05-12 16:15:01] <aniketp41> 		atf_tc_fail("Preselection mode: %s", strerror(errno));
[2018-05-12 16:15:01] <aniketp41> 	/* Set local preselection flag corresponding to the audit_event */
[2018-05-12 16:15:01] <aniketp41> 	if (ioctl(filedesc, AUDITPIPE_SET_PRESELECT_FLAGS, fmask) < 0)
[2018-05-12 16:15:01] <aniketp41> 		atf_tc_fail("Preselection flag: %s", strerror(errno));
[2018-05-12 16:15:01] <aniketp41> 	/* Set local preselection flag for non-attributable audit_events */
[2018-05-12 16:15:01] <aniketp41> 	if (ioctl(filedesc, AUDITPIPE_SET_PRESELECT_NAFLAGS, fmask) < 0)
[2018-05-12 16:15:01] <aniketp41> 		atf_tc_fail("Preselection flag: %s", strerror(errno));
[2018-05-12 16:15:01] <aniketp41> }
[2018-05-12 16:15:01] <aniketp41>  * Get the corresponding audit_mask for class-name "name" then set the
[2018-05-12 16:15:01] <aniketp41>  * success and failure bits for fmask to be used as the ioctl argument
[2018-05-12 16:15:01] <aniketp41>  */
[2018-05-12 16:15:01] <aniketp41> static au_mask_t
[2018-05-12 16:15:01] <aniketp41> get_audit_mask(const char *name)
[2018-05-12 16:15:01] <aniketp41> {
[2018-05-12 16:15:01] <aniketp41> 	au_mask_t fmask;
[2018-05-12 16:15:01] <aniketp41> 	au_class_ent_t *class;
[2018-05-12 16:15:01] <aniketp41> 	ATF_REQUIRE((class = getauclassnam(name)) != NULL);
[2018-05-12 16:15:01] <aniketp41> 	fmask.am_success = class->ac_class;
[2018-05-12 16:15:01] <aniketp41> 	fmask.am_failure = class->ac_class;
[2018-05-12 16:15:01] <aniketp41> 	ATF_REQUIRE((class = getauclassnam("ad")) != NULL);
[2018-05-12 16:15:01] <aniketp41> 	fmask.am_success |= class->ac_class;
[2018-05-12 16:15:01] <aniketp41> 	return (fmask);
[2018-05-12 16:15:01] <aniketp41> }
[2018-05-12 16:15:01] <aniketp41>  * Loop until the auditpipe returns something, check if it is what
[2018-05-12 16:15:01] <aniketp41>  * we want, else repeat the procedure until ppoll(2) times out.
[2018-05-12 16:15:01] <aniketp41>  */
[2018-05-12 16:15:01] <aniketp41> static void
[2018-05-12 16:15:01] <aniketp41> check_auditpipe(struct pollfd fd[], const char *auditregex, FILE *pipestream)
[2018-05-12 16:15:01] <aniketp41> {
[2018-05-12 16:15:01] <aniketp41> 	struct timespec currtime, endtime, timeout;
[2018-05-12 16:15:01] <aniketp41> 	/* Set the expire time for poll(2) while waiting for syscall audit */
[2018-05-12 16:15:01] <aniketp41> 	ATF_REQUIRE_EQ(0, clock_gettime(CLOCK_MONOTONIC, &endtime));
[2018-05-12 16:15:01] <aniketp41> 	endtime.tv_sec += 5;
[2018-05-12 16:15:01] <aniketp41> 	timeout.tv_nsec = endtime.tv_nsec;
[2018-05-12 16:15:01] <aniketp41> 	for (;;) {
[2018-05-12 16:15:01] <aniketp41> 		/* Update the time left for auditpipe to return any event */
[2018-05-12 16:15:01] <aniketp41> 		ATF_REQUIRE_EQ(0, clock_gettime(CLOCK_MONOTONIC, &currtime));
[2018-05-12 16:15:01] <aniketp41> 		timeout.tv_sec = endtime.tv_sec - currtime.tv_sec;
[2018-05-12 16:15:01] <aniketp41> 		switch (ppoll(fd, 1, &timeout, NULL)) {
[2018-05-12 16:15:01] <aniketp41> 		/* ppoll(2) returns, check if it's what we want */
[2018-05-12 16:15:01] <aniketp41> 		case 1:
[2018-05-12 16:15:01] <aniketp41> 			if (fd[0].revents & POLLIN) {
[2018-05-12 16:15:01] <aniketp41> 				if (get_records(auditregex, pipestream))
[2018-05-12 16:15:01] <aniketp41> 					return;
[2018-05-12 16:15:01] <aniketp41> 			} else {
[2018-05-12 16:15:01] <aniketp41> 				atf_tc_fail("Auditpipe returned an "
[2018-05-12 16:15:01] <aniketp41> 				"unknown event %#x", fd[0].revents);
[2018-05-12 16:15:01] <aniketp41> 			}
[2018-05-12 16:15:01] <aniketp41> 			break;
[2018-05-12 16:15:01] <aniketp41> 		/* poll(2) timed out */
[2018-05-12 16:15:01] <aniketp41> 		case 0:
[2018-05-12 16:15:01] <aniketp41> 			atf_tc_fail("Auditpipe did not return anything "
[2018-05-12 16:15:01] <aniketp41> 					"within the time limit");
[2018-05-12 16:15:01] <aniketp41> 			break;
[2018-05-12 16:15:01] <aniketp41> 		/* poll(2) standard error */
[2018-05-12 16:15:01] <aniketp41> 		case -1:
[2018-05-12 16:15:01] <aniketp41> 			atf_tc_fail("Poll: %s", strerror(errno));
[2018-05-12 16:15:01] <aniketp41> 			break;
[2018-05-12 16:15:01] <aniketp41> 		default:
[2018-05-12 16:15:01] <aniketp41> 			atf_tc_fail("Poll returned an unknown event");
[2018-05-12 16:15:01] <aniketp41> 		}
[2018-05-12 16:15:01] <aniketp41> 	}
[2018-05-12 16:15:01] <aniketp41> }
[2018-05-12 16:15:01] <aniketp41>  * Wrapper functions around static "check_auditpipe"
[2018-05-12 16:15:01] <aniketp41>  */
[2018-05-12 16:15:01] <aniketp41> static void
[2018-05-12 16:15:01] <aniketp41> check_audit_startup(struct pollfd fd[], const char *auditrgx, FILE *pipestream) {
[2018-05-12 16:15:01] <aniketp41> 	check_auditpipe(fd, auditrgx, pipestream);
[2018-05-12 16:15:01] <aniketp41> }
[2018-05-12 16:15:01] <aniketp41> void
[2018-05-12 16:15:01] <aniketp41> check_audit(struct pollfd fd[], const char *auditrgx, FILE *pipestream) {
[2018-05-12 16:15:01] <aniketp41> 	check_auditpipe(fd, auditrgx, pipestream);
[2018-05-12 16:15:01] <aniketp41> 	/* Cleanup */
[2018-05-12 16:15:01] <aniketp41> 	fclose(pipestream);
[2018-05-12 16:15:01] <aniketp41> 	close(fd[0].fd);
[2018-05-12 16:15:01] <aniketp41> }
[2018-05-12 16:15:01] <aniketp41> FILE
[2018-05-12 16:15:01] <aniketp41> *setup(struct pollfd fd[], const char *name)
[2018-05-12 16:15:01] <aniketp41> {
[2018-05-12 16:15:01] <aniketp41> 	au_mask_t fmask;
[2018-05-12 16:15:01] <aniketp41> 	fmask = get_audit_mask(name);
[2018-05-12 16:15:01] <aniketp41> 	FILE *pipestream;
[2018-05-12 16:15:01] <aniketp41> 	fd[0].fd = open("/dev/auditpipe", O_RDONLY);
[2018-05-12 16:15:01] <aniketp41> 	fd[0].events = POLLIN;
[2018-05-12 16:15:01] <aniketp41> 	pipestream = fdopen(fd[0].fd, "r");
[2018-05-12 16:15:01] <aniketp41> 	set_preselect_mode(fd[0].fd, &fmask);
[2018-05-12 16:15:01] <aniketp41> 	ATF_REQUIRE_EQ(0, system("service auditd onestatus || \
[2018-05-12 16:15:01] <aniketp41> 	{ service auditd onestart && touch started_auditd ; }"));
[2018-05-12 16:15:01] <aniketp41> 	/* This removes any outstanding record on the auditpipe */
[2018-05-12 16:15:01] <aniketp41> 	if (ioctl(fd[0].fd, AUDITPIPE_FLUSH) < 0)
[2018-05-12 16:15:01] <aniketp41> 		atf_tc_fail("Auditpipe flush: %s", strerror(errno));
[2018-05-12 16:15:01] <aniketp41> 	/* If 'started_auditd' exists, that means we started auditd(8) */
[2018-05-12 16:15:01] <aniketp41> 	if (atf_utils_file_exists("started_auditd"))
[2018-05-12 16:15:01] <aniketp41> 		check_audit_startup(fd, "audit startup", pipestream);
[2018-05-12 16:15:01] <aniketp41> 	return (pipestream);
[2018-05-12 16:15:01] <aniketp41> }
[2018-05-12 16:15:01] <aniketp41> void
[2018-05-12 16:15:01] <aniketp41> cleanup(void)
[2018-05-12 16:15:01] <aniketp41> {
[2018-05-12 16:15:01] <aniketp41> 	system("[ -f started_auditd ] && service auditd onestop > \
[2018-05-12 16:15:01] <aniketp41> 		/dev/null 2>&1");
[2018-05-12 16:15:01] <aniketp41> }
[2018-05-12 16:15:02] * aniketp41 (~aniketp41@159.65.149.37) quit Excess Flood
[2018-05-12 16:15:17] * aniketp41 (~aniketp41@159.65.149.37) join
[2018-05-12 16:15:35] <aniketp41> Oh sorry that was the wrong paste 
[2018-05-12 16:15:49] <aniketp41> Here: https://github.com/openbsm/openbsm/blob/master/libbsm/bsm_io.c#L4669
[2018-05-12 16:43:55] <aniketp41> Hi @rwatson, is it possible that audit records might not have complete audit tokens or contain few erroneous data?
[2018-05-12 16:45:54] <aniketp41> I had a look at the source code of "au_read_rec" and I couldn't find any anomaly, however if for some reason the audit record is corrupted even before au_read_rec reads it into a buffer, we might not be able to get complete and santized tokens..
[2018-05-12 17:24:40] <somers_> Does your program actually check that au_read_rec doesn't return an error?
[2018-05-12 17:39:00] <aniketp41> Not until now, I've added an ATF_REQUIRE check on au_read_rec function. But my tests aren't failing so I can't see if there is any difference.. @somers_, can you add that check and see if the result is any different?
[2018-05-12 17:39:19] <somers_> Sure
[2018-05-12 17:44:48] <somers_> are you going to send me the code?
[2018-05-12 17:46:41] <aniketp41> Oh, sorry. Yes here is my utils.c : https://pastebin.com/2byYdEJ2
[2018-05-12 17:46:41] <aniketp41> somers_
[2018-05-12 17:48:36] <somers_> It's hard to tell what the difference is.  Can you upload it to Phabricator, or at least send me a diff vs what's in Phabricator?
[2018-05-12 17:54:09] <aniketp41> Okay, @somers_. I've updated the review. Please have a look
[2018-05-12 18:00:54] <somers_> Same as before.  Most tests timed out if auditd wasn't already running.
[2018-05-12 18:03:42] <aniketp41> So there wasn't any "incomplete audit record" error? @somers_ 
[2018-05-12 18:03:42] <aniketp41> Also, about timeout errors, what if we move the flush part right before infinite for loop? Cause if the tests timeout just in case auditd(8) isn't already running, that means we have issue in auditing "audit startup"
[2018-05-12 18:04:24] <aniketp41> And that audit record isn't incomplete since tests pass for "auditd" already running scenario
[2018-05-12 18:05:34] <somers_> I think you're probably still overflowing the queue length.  One thing you could do would be to increase the queue length.  Another would be to flush the queue after the "audit startup" message.  Another would be to deselect the "ad" class after the auditd startup
[2018-05-12 18:05:35] <aniketp41> Though is it possible that even though I update the diff, our "utils.c" is not exactly same? In that case please check the tests by using the utils.c from pastebin
[2018-05-12 18:08:06] <aniketp41> @somers_, tests aren't failing for me so I'll not be able to check any difference. Can you please try these changes on your machine and see if it works. Queue overflow might be an explanation in your case cause when your Q_LEN showed 128, mine was only 2..
[2018-05-12 18:08:08] <somers_> I used exactly what you posted to Phabricator
[2018-05-12 18:09:20] <somers_> Do you run your tests with sudo, or do you login as root?
[2018-05-12 18:09:53] <aniketp41> Yes I'm working as a root. I removed my user as I didn't need it
[2018-05-12 18:14:05] <somers_> It's possible that sudo produces extra auditable events, making it more likely for the queue to overflow
[2018-05-12 18:14:59] <aniketp41> Okay I'll try to run these tests as a user with sudo
[2018-05-12 18:15:05] <aniketp41> @somers_ 
[2018-05-12 18:17:45] <aniketp41> @somers_, they passed as sudo too: https://pastebin.com/eWqHnSDn
[2018-05-12 18:22:12] <aniketp41> @somers_, can we try setting Q_LIMIT to see if it works? or maybe calling AUDITPIPE_FLUSH both before and after "audit_check"
[2018-05-12 18:23:29] <somers_> yeah, I'm trying that now
[2018-05-12 18:33:20] <somers_> Flushing the pipe before and after "audit startup" increases the pass rate.  Raising the queue size has about the same effect.  Doing both results in a really annoying pass rate of 99% or so.
[2018-05-12 18:35:37] <aniketp41> Looks like there are a hell lot events being generated on your machine? Maybe a lot of administrative "ad" events are also getting audited..
[2018-05-12 18:37:26] <aniketp41> BTW @somers_, Is there a limit on how much we can raise Q_LIMIT? maybe we can make it the maximum it can be
[2018-05-12 18:38:00] <somers_> Yeah, there's an ioctl that will tell you what the max is.  That's what I'm using, and it's 1024
[2018-05-12 18:49:39] <aniketp41> @somers_, I think my placement of AUDITPIPE_FLUSH was wrong earlier, I should've placed it once before "audit startup" and another after "check_audit_startup". I placed it between them
[2018-05-12 18:50:45] <aniketp41> I think that might have erased "audit startup" event from your auditpipe in case it was not already running. That might explain why they failed for you?
[2018-05-12 18:50:45] <aniketp41> But if that is the case, then they should've failed for me too?
[2018-05-12 18:51:54] <aniketp41> Or maybe my system wasn't fast enough to remove the trail from auditpipe before auditd started? 
[2018-05-12 18:51:54] <aniketp41> Here is my modifed setup function: https://pastebin.com/BtqiSmwY
[2018-05-12 19:05:49] <aniketp41> ping @somers_ 
[2018-05-12 19:08:20] <somers_> When I move the AUDITPIPE_FLUSH as you suggest, most tests fail with "Incomplete audit record"
[2018-05-12 19:33:08] <aniketp41> That's strange, we had a check in place for au_read_rec(3) to return -1. Not sure why au_fetch_tok(3) is giving an error.
[2018-05-12 19:33:08] <aniketp41> Btw @somers_, can you try replacing "reclen - bytes" with "reclen"? Although that's wrong, but "incomplete audit record" doesn't make any sense now ... 
[2018-05-12 19:34:12] <aniketp41> Btw @somers_, do the tests fail in both scenario? i.e auditd(8) running or not
[2018-05-13 13:56:50] <aniketp41> Hello @somers_, I had been thinking, do we really need that check for "au_fetch_tok" to not be equal to "-1" in every iteration? Cause I've developed about 144 test-cases and for tests of "file-read" audit_class, I was getting a similar "incomplete audit record" error but when I removed that condition all tests passed
[2018-05-13 14:01:37] <aniketp41> Please have a look at the difference in result before and after the if-condition change: https://pastebin.com/ddZ88RAd
[2018-05-13 14:02:55] <aniketp41> @somers_, Please remove the if condition and then run your tests again! 
[2018-05-13 15:23:17] <aniketp41> ping @somers_ 
[2018-05-13 15:32:01] <somers_> It's possible that the only records getting corrupted are extraneous records, like from the "ad" class.  But it would be good to know which.  Could you at least try printing the incomplete record as a warning?  Then we might be able to tell.
[2018-05-13 15:32:24] <somers_> Another thing you could do would be to deselect the "ad" class after auditd startup is complete.
[2018-05-13 15:39:34] <somers_> @aniketp41 with your latest changes, most testcases fail with this error: "failed: /usr/home/somers/freebsd/base/head/tests/sys/audit/utils.c:65: (reclen = au_read_rec(pipestream, &buff)) != -1 not met"
[2018-05-13 16:47:32] <aniketp41> @somers_, is this the right way to remove a flag?: am_success = am_sucess & ~class->ac_class
[2018-05-13 16:48:24] <somers_> Sure.  Though in your case, it would probably be equally easy to simply start from scratch
[2018-05-13 16:48:50] <somers_> Actually, your snippet would be wrong if the syscall under test _is_ in class "ad".
[2018-05-13 16:50:00] <aniketp41> I think @somers_, going by that logic (corrupted extraneous) wouldn't it be right to replace ATF_REQUIRE in au_read_rec with a warn statement? cause I guess those corrupted records might be failing the tests again?
[2018-05-13 16:50:20] <aniketp41> Oops, true! Didn't think of "ad" syscall :D
[2018-05-13 17:13:19] <aniketp41> @somers_, I made few more changes, please have a look at the revision
[2018-05-13 17:23:58] <somers_> I gtg.  I'll look in a couple of hours
[2018-05-13 17:25:01] <aniketp41> Sure
[2018-05-13 18:30:35] <aniketp41> @rwatson, @somers_ what should I do about the syscalls which don't have any manpage? Like for instance I'm having a look at the "file-attribute-access" system calls and quite a lot a them don't have manual pages.
[2018-05-13 21:20:01] <somers_> most of them probably have man pages under a slightly different name, because there's a wrapper in libc.
[2018-05-13 21:21:20] <somers_> You can grep for the syscall's name under lib/libc/gen
[2018-05-13 21:21:40] <somers_> Or just under lib.  Some of them, like the pthreads-related stuff, aren't technically in libc.
[2018-05-14 00:54:46] <aniketp41> Sure @somers_, I'll have a look at the  location for the syscalls. Btw did you have a look at the recent changes?
[2018-05-14 00:55:43] <aniketp41> I've called "set_preselect_mode" twice,. as you suggested for both audit startup abs syscall audit
